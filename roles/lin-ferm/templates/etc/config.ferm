# fERM rules
# ansible-managed

@def $openvz = {{ ferm_openvz |bool |ternary(1,0) }};
{% if ferm_ipv4 |bool and ferm_ipv6 |bool %}
@def $ip_all = (ip ip6);
{% elif ferm_ipv4 |bool or ferm_ipv6 |bool %}
@def $ip_all = {{ ferm_ipv4 |bool |ternary('ip','ip6') }};
{% else %}
@def $ip_all = ();
{% endif %}
@def $do_ipv4 = {{ ferm_ipv4 |bool |ternary(1,0) }};
@def $do_ipv6 = {{ ferm_ipv6 |bool |ternary(1,0) }};
@def $do_ufw = {{ ferm_mimic_ufw |bool |ternary(1,0) }};

@def $docker_make_chains = {{ ferm_docker_make_chains |bool |ternary(1,0) }};
@def $docker_bridge = {{ ferm_docker_bridge |default('docker0') }};
@def $docker_subnet4 = {{ ferm_docker_subnet4 }};

# aliases for hooked chains
@def $PREROUTING = _PREROUTING;
@def $POSTROUTING = _POSTROUTING;
@def $INPUT = _INPUT;
@def $OUTPUT = _OUTPUT;
@def $FORWARD = _FORWARD;

# $first_run is non-zero if hook isn't found in the forward chain
# use 'export FERM_FORCE_HOOKS=1' to force inserting the hooks
# note: skip xtables lock here since we lock the whole process
{#
 # we could use strace instead of helper shared library, like this:
 # `strace -o /dev/null -e flock -e inject=flock:retval=0 iptables`
 # but `inject` is not supported on ubuntu 16.04
 #}
@def $first_run = `LD_PRELOAD="{{ ferm_lib_nolock }}" iptables -C FORWARD -j _FORWARD 2>/dev/null; echo "${FERM_FORCE_HOOKS}$?"`;

@def &CHAIN_HOOK($chain, $policy) = {
    @def $hook = @cat('_', $chain);
    @if $first_run {
        # create standard chain and embed the hook
        chain $chain policy $policy;
        chain $hook;
        chain $chain jump $hook;
    } @else {
        # build hooked chain, preserve original chain
        chain $chain @preserve;
        chain $hook;
    }
}

# Setup chains

@if $do_ipv4 domain ip {
    table raw {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
    }
    table mangle {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        &CHAIN_HOOK(INPUT, ACCEPT);
        &CHAIN_HOOK(FORWARD, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
        &CHAIN_HOOK(POSTROUTING, ACCEPT);
    }
    table nat {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        @if @not($openvz) &CHAIN_HOOK(INPUT, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
        &CHAIN_HOOK(POSTROUTING, ACCEPT);
    }
    table filter {
        &CHAIN_HOOK(INPUT, DROP);
        &CHAIN_HOOK(FORWARD, DROP);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
    }
}

@if $do_ipv6 domain ip6 {
    @if @not($openvz) table raw {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
    }
    table mangle {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        &CHAIN_HOOK(INPUT, ACCEPT);
        &CHAIN_HOOK(FORWARD, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
        &CHAIN_HOOK(POSTROUTING, ACCEPT);
    }
    @if @not($openvz) table nat {
        &CHAIN_HOOK(PREROUTING, ACCEPT);
        &CHAIN_HOOK(INPUT, ACCEPT);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
        &CHAIN_HOOK(POSTROUTING, ACCEPT);
    }
    table filter {
        &CHAIN_HOOK(INPUT, DROP);
        &CHAIN_HOOK(FORWARD, DROP);
        &CHAIN_HOOK(OUTPUT, ACCEPT);
    }
}

# HEADS UP! errors in ferm-ipset/ferm-openvz will be ignored!
@if $openvz {
    # setup host/port multi-lists
    @include "{{ ferm_bindir }}/ferm-openvz -c {{ ferm_dir }} -l {{ ferm_ipset_files |join(',') }} -o {{ ferm_openvz_file }} -O |";

    @include @glob('custom/*.ferm');
} @else {
    # setup host/port ipsets
    @hook pre "{{ ferm_bindir }}/ferm-ipset -c {{ ferm_dir }} -l {{ ferm_ipset_files |join(',') }}";

    @include @glob('custom/*.ferm');
}
