---
- name: install docker helpers
  apt:
    name:
      ## note: jq helps to parse docker output
      - jq
      - pigz
      - bash-completion
      - criu

- name: install extra docker tools
  apt:
    name:
      - bridge-utils
      - ipvsadm
      - apache2-utils
      - siege
  when: docker_extras |bool

- name: add docker signing key
  apt_key:
    url: https://download.docker.com/linux/ubuntu/gpg
  register: add_docker_key_result
  until: add_docker_key_result is successful
  when: docker_from_docker_io |bool

- name: add docker repository
  apt_repository:
    repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ codename }} stable"
    filename: docker-ce
    mode: 0644
  register: add_docker_repo_result
  until: add_docker_repo_result is successful
  when: docker_from_docker_io |bool
  vars:
    ## workaround for docker repo not yet ready on focal
    codename: "{{ 'eoan' if _codename == 'focal' and docker_focal_fix |bool else _codename }}"
    _codename: "{{ ansible_lsb.codename }}"

- block:
    - name: install docker and friends
      apt:
        name: "{{ packages_docker }}"
        state: "{{ docker_upgrade |bool |ternary('latest', 'present') }}"
        autoremove: true
        install_recommends: false
  rescue:
    - name: install docker and friends (update apt cache)
      apt:
        name: "{{ packages_docker }}"
        state: "{{ docker_upgrade |bool |ternary('latest', 'present') }}"
        autoremove: true
        install_recommends: false
        update_cache: true
  vars:
    packages_docker: "{{ docker_from_docker_io |bool |ternary(pkgs_dockerio, pkgs_ubuntu) }}"
    pkgs_ubuntu: docker.io,docker-compose
    pkgs_dockerio: docker-ce


- name: bash completion script for docker
  file:
    src: /usr/share/bash-completion/completions/docker
    dest: /etc/bash_completion.d/docker
    state: link

- name: user bash aliases for docker cli (optional)
  blockinfile:
    path: ~/.local/bashrc/4alias.sh
    block: |
      {% for item in docker_bash_aliases |dictsort %}
      alias {{ item.0 }}='{{ item.1 }}'
      {% endfor %}
    marker: '# {mark} DOCKER ALIASES'
  become: false
  when: user_local_bashrc.stat.exists
  tags: lin_docker_user

- name: user bash functions for docker cli (optional)
  blockinfile:
    path: ~/.local/bashrc/3common.sh
    block: "{{ lookup('file', 'bashrc.docker.sh') }}"
    marker: '# {mark} DOCKER FUNCTIONS'
    insertafter: EOF
  become: false
  when: user_local_bashrc.stat.exists
  tags: lin_docker_user

- name: user bash completion for docker cli (optional)
  lineinfile:
    path: ~/.local/bashrc/5completion.sh
    line: 'complete -F _docker dr'
  become: false
  when: user_local_bashrc.stat.exists
  tags: lin_docker_user


- name: configure docker daemon
  import_tasks: daemon.yml
  tags: lin_docker_daemon

- name: enable docker service
  systemd:
    name: docker
    state: started
    enabled: true
    daemon_reload: "{{ _docker_systemd_dropin |d({}) is changed }}"
  tags: lin_docker_daemon


- name: query gwbridge network parameters
  docker_network_info:
    name: docker_gwbridge
  ignore_errors: true
  register: _gwbridge_info
  when: docker_gwbridge_addr4 |d('')
  tags: lin_docker_gwbridge

- name: configure gwbridge network
  ## Warning: if node is part of swarm, this step will fail with error:
  ## "error while removing network: docker_gwbridge has active endpoints"
  ## Force by: docker_gwbridge_force=true
  ## Note: run shell commands since docker_network fails here with error:
  ## docker.errors.NotFound ("No such container: gateway_ingress-sbox")
  shell:
    cmd: >
      {{ gwbridge_force_cmd }} &&
      yes| docker network remove docker_gwbridge &&
      docker network create {{ arg_subnet4 }} {{ arg_opts.strip() }} docker_gwbridge
  vars:
    old_net: "{{ _gwbridge_info.network.IPAM.Config.0.Subnet |d(none) }}"
    old_gwy: "{{ _gwbridge_info.network.IPAM.Config.0.Gateway |d(none) }}"
    new_net: "{{ docker_gwbridge_addr4 |d(old_net, true) |ipaddr('network/prefix') }}"
    new_gwy: "{{ docker_gwbridge_addr4 |d(old_gwy, true) |ipaddr('address') }}"
    arg_subnet4: "--subnet {{ new_net }} --gateway {{ new_gwy }}"
    old_opts: "{{ _gwbridge_info.network.Options |d({}) }}"
    arg_opts: >
      {% set ns = namespace(lst=[]) -%}
      {% for key, val in old_opts.items() |sort -%}
        {% set ns.lst = ns.lst + ['-o %s=%s' |format(key, val)] -%}
      {% endfor -%}
      {{ ns.lst |join(' ') }}
    leave_swarm_cmd: '(docker swarm leave --force || true)'
    gwbridge_force_cmd: "{{ docker_gwbridge_force |bool |ternary(leave_swarm_cmd, 'true') }}"
  when:
    - _gwbridge_info is successful
    - _gwbridge_info.exists |d(false) |bool
    - old_net != new_net or old_gwy != new_gwy
  tags: lin_docker_gwbridge
...
